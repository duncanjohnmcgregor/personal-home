name: Continuous Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch: # Allow manual deployment
  workflow_run:
    workflows: ["Continuous Integration"]
    types:
      - completed
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    # Only run if CI completed successfully, or if manually triggered
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' || github.event_name == 'push' }}
    
    env:
      POSTGRES_PRISMA_URL: ${{ secrets.POSTGRES_PRISMA_URL }}
      POSTGRES_URL_NON_POOLING: ${{ secrets.POSTGRES_URL_NON_POOLING }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
      SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
      SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
      SOUNDCLOUD_CLIENT_ID: ${{ secrets.SOUNDCLOUD_CLIENT_ID }}
      BEATPORT_CLIENT_ID: ${{ secrets.BEATPORT_CLIENT_ID }}
      BEATPORT_CLIENT_SECRET: ${{ secrets.BEATPORT_CLIENT_SECRET }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Determine Cache Key Strategy
      id: cache-strategy
      run: |
        echo "üîç Determining cache key strategy..."
        
        # Determine the correct SHA to use for cache lookup
        if [ "${{ github.event_name }}" == "workflow_run" ]; then
          # For workflow_run events, use the SHA from the triggering workflow
          CACHE_SHA="${{ github.event.workflow_run.head_sha }}"
          echo "üìã Workflow run event detected"
          echo "   Triggering SHA: ${{ github.event.workflow_run.head_sha }}"
          echo "   Current SHA: ${{ github.sha }}"
        else
          # For direct push or manual dispatch, use current SHA
          CACHE_SHA="${{ github.sha }}"
          echo "üìã Direct push/manual event detected"
          echo "   Using current SHA: ${{ github.sha }}"
        fi
        
        # Set outputs for use in cache steps
        echo "cache-sha=${CACHE_SHA}" >> $GITHUB_OUTPUT
        echo "cache-key=${{ runner.os }}-build-artifacts-${CACHE_SHA}" >> $GITHUB_OUTPUT
        echo "node-cache-key=${{ runner.os }}-node-modules-${{ hashFiles('**/package-lock.json') }}" >> $GITHUB_OUTPUT
        echo "build-cache-key=${{ runner.os }}-build-cache-${{ hashFiles('**/package-lock.json', '**/prisma/schema.prisma') }}" >> $GITHUB_OUTPUT
        
        echo "‚úÖ Cache strategy determined:"
        echo "   Cache SHA: ${CACHE_SHA}"
        echo "   Build artifacts key: ${{ runner.os }}-build-artifacts-${CACHE_SHA}"

    - name: Restore Cached Build Artifacts
      uses: actions/cache@v3
      id: cache-artifacts
      with:
        path: |
          .next
          node_modules/.prisma
          node_modules
          deployment-info.json
        key: ${{ steps.cache-strategy.outputs.cache-key }}
        restore-keys: |
          ${{ runner.os }}-build-artifacts-

    - name: Restore Additional Build Cache
      uses: actions/cache@v3
      id: cache-build-extras
      with:
        path: |
          .next/cache
          node_modules/.cache
        key: ${{ steps.cache-strategy.outputs.build-cache-key }}
        restore-keys: |
          ${{ runner.os }}-build-cache-

    - name: Verify Cached Artifacts or Build
      run: |
        echo "üîç Verifying cached artifacts..."
        echo "Cache hit status: ${{ steps.cache-artifacts.outputs.cache-hit }}"
        echo "Expected cache key: ${{ steps.cache-strategy.outputs.cache-key }}"
        
        # Check if we got a cache hit and deployment info exists
        if [ "${{ steps.cache-artifacts.outputs.cache-hit }}" == "true" ] && [ -f "deployment-info.json" ]; then
          echo "‚úÖ Cache hit! Using cached build artifacts."
          echo ""
          echo "üìã Cached Deployment Info:"
          cat deployment-info.json | jq '.' 2>/dev/null || cat deployment-info.json
          
          # Verify critical cached artifacts exist and are valid
          if [ ! -d ".next" ]; then
            echo "‚ùå Critical: .next directory missing from cache"
            NEEDS_REBUILD=true
          elif [ ! -f ".next/BUILD_ID" ]; then
            echo "‚ùå Critical: BUILD_ID missing from cache"
            NEEDS_REBUILD=true
          elif [ ! -d "node_modules/.prisma" ]; then
            echo "‚ùå Critical: Prisma client missing from cache"
            NEEDS_REBUILD=true
          elif [ ! -d "node_modules" ]; then
            echo "‚ùå Critical: node_modules missing from cache"
            NEEDS_REBUILD=true
          else
            echo "‚úÖ All cached artifacts verified successfully"
            echo "üöÄ Ready for fast deployment!"
            NEEDS_REBUILD=false
          fi
        else
          echo "‚ö†Ô∏è Cache miss occurred! Details:"
          echo "   Cache hit: ${{ steps.cache-artifacts.outputs.cache-hit }}"
          echo "   Deployment info exists: $(test -f deployment-info.json && echo 'yes' || echo 'no')"
          echo "   Expected cache key: ${{ steps.cache-strategy.outputs.cache-key }}"
          echo ""
          echo "üîç Possible causes:"
          echo "   1. CI workflow didn't complete successfully"
          echo "   2. Cache key mismatch between CI and CD workflows"
          echo "   3. Cache expired or was evicted"
          echo "   4. Different commit SHA between CI and CD"
          echo ""
          echo "‚ÑπÔ∏è Will rebuild fresh artifacts for deployment..."
          NEEDS_REBUILD=true
        fi
        
        if [ "$NEEDS_REBUILD" == "true" ]; then
          echo ""
          echo "üèóÔ∏è Rebuilding application artifacts..."
          
          # Install dependencies if not cached properly
          if [ ! -d "node_modules" ] || [ ! -f "node_modules/.package-lock.json" ]; then
            echo "üì¶ Installing dependencies..."
            npm ci
          else
            echo "‚úÖ Dependencies already available"
          fi
          
          # Generate Prisma client if not cached properly
          if [ ! -d "node_modules/.prisma" ]; then
            echo "üîß Generating Prisma client..."
            npx prisma generate
          else
            echo "‚úÖ Prisma client already available"
          fi
          
          # Build application if not cached properly
          if [ ! -d ".next" ] || [ ! -f ".next/BUILD_ID" ]; then
            echo "üèóÔ∏è Building Next.js application..."
            npm run build
          else
            echo "‚úÖ Next.js build already available"
          fi
          
          # Create deployment info for tracking
          echo "üìã Creating fresh deployment info..."
          cat > deployment-info.json << EOF
        {
          "buildId": "$(cat .next/BUILD_ID 2>/dev/null || echo 'fresh-build')",
          "nodeVersion": "$(node --version)",
          "npmVersion": "$(npm --version)",
          "timestamp": "$(date -u -Iseconds)",
          "gitCommit": "${{ steps.cache-strategy.outputs.cache-sha }}",
          "gitRef": "${{ github.ref }}",
          "prismaVersion": "$(npx prisma --version | head -n1)",
          "cacheKeys": {
            "nodeModules": "${{ steps.cache-strategy.outputs.node-cache-key }}",
            "buildArtifacts": "${{ steps.cache-strategy.outputs.cache-key }}"
          },
          "rebuildReason": "Cache miss - fresh build required"
        }
        EOF
          
          echo "‚úÖ Fresh build completed successfully"
        fi
        
        # Final verification that all required artifacts exist
        echo ""
        echo "üîç Final artifact verification..."
        
        if [ ! -d ".next" ]; then
          echo "‚ùå Build artifacts missing: .next directory not found"
          exit 1
        fi
        
        if [ ! -d "node_modules/.prisma" ]; then
          echo "‚ùå Prisma client missing: node_modules/.prisma not found" 
          exit 1
        fi
        
        if [ ! -d "node_modules" ]; then
          echo "‚ùå Dependencies missing: node_modules not found"
          exit 1
        fi
        
        echo "‚úÖ All deployment artifacts verified and ready"
        echo ""
        echo "üìä Deployment Performance Summary:"
        if [ "${{ steps.cache-artifacts.outputs.cache-hit }}" == "true" ]; then
          echo "   ‚ö° Used cached artifacts (fast deployment)"
        else
          echo "   üèóÔ∏è Built fresh artifacts (standard deployment)"
        fi

    - name: Install Vercel CLI
      run: |
        echo "üì¶ Installing Vercel CLI..."
        npm install --global vercel@latest
        echo "‚úÖ Vercel CLI ready"

    - name: Verify Environment Variables
      run: |
        echo "üîç Verifying production environment variables..."
        
        # Check if environment variables are properly set
        if [ -n "$POSTGRES_PRISMA_URL" ]; then
          echo "‚úÖ POSTGRES_PRISMA_URL is available"
        else
          echo "‚ùå POSTGRES_PRISMA_URL is not available in environment"
          exit 1
        fi
        
        if [ -n "$POSTGRES_URL_NON_POOLING" ]; then
          echo "‚úÖ POSTGRES_URL_NON_POOLING is available"
        else
          echo "‚ùå POSTGRES_URL_NON_POOLING is not available in environment"
          exit 1
        fi
        
        if [ -n "$NEXTAUTH_SECRET" ]; then
          echo "‚úÖ NEXTAUTH_SECRET is available"
        else
          echo "‚ùå NEXTAUTH_SECRET is not available in environment"
          exit 1
        fi
        
        if [ -z "${{ secrets.VERCEL_TOKEN }}" ]; then
          echo "‚ùå VERCEL_TOKEN secret is not set!"
          echo ""
          echo "üîß To fix this:"
          echo "1. Go to https://vercel.com/account/tokens"
          echo "2. Create a new token named 'GitHub Actions'"
          echo "3. Copy the token"
          echo "4. Go to GitHub repo ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions"
          echo "5. Add secret named 'VERCEL_TOKEN' with the token value"
          echo ""
          echo "üìñ See VERCEL_SECRETS_SETUP.md for detailed instructions"
          exit 1
        else
          echo "‚úÖ VERCEL_TOKEN is configured"
        fi
        
        echo "‚úÖ All required environment variables verified"

    - name: Database Connection and Schema Deployment
      run: |
        echo "üóÑÔ∏è Setting up production database..."
        echo "===================================="
        
        # Test database connectivity first
        echo ""
        echo "üîç Testing database connection..."
        
        # Create a lightweight connection test script
        cat > test-connection.js << 'EOF'
        const { PrismaClient } = require('@prisma/client')
        
        const prisma = new PrismaClient({
          log: ['error', 'warn'],
        })
        
        async function testConnection() {
          try {
            console.log('üîç Testing database connection...')
            
            // Test basic connection
            await prisma.$connect()
            console.log('‚úÖ Database connection established')
            
            // Test query execution
            await prisma.$queryRaw`SELECT 1 as connection_test`
            console.log('‚úÖ Database query execution successful')
            
            console.log('‚úÖ Connection test passed!')
            process.exit(0)
            
          } catch (error) {
            console.error('‚ùå Database connection failed:')
            console.error('Error details:', error.message)
            
            if (error.message.includes('ENOTFOUND')) {
              console.error('üîç This appears to be a DNS/network issue')
            } else if (error.message.includes('authentication')) {
              console.error('üîç This appears to be an authentication issue')
            } else if (error.message.includes('database') && error.message.includes('does not exist')) {
              console.error('üîç Database does not exist')
            }
            
            process.exit(1)
          } finally {
            await prisma.$disconnect()
          }
        }
        
        testConnection()
        EOF
        
        # Run connection test
        if node test-connection.js; then
          echo "‚úÖ Database connection test passed"
        else
          echo "‚ùå Database connection test failed"
          exit 1
        fi
        
        # Deploy migrations
        echo ""
        echo "üöÄ Deploying database migrations..."
        if npx prisma migrate deploy; then
          echo "‚úÖ Database migrations deployed successfully!"
        else
          echo "‚ö†Ô∏è Migration deploy failed, trying schema push..."
          if npx prisma db push --accept-data-loss; then
            echo "‚úÖ Database schema pushed successfully!"
          else
            echo "‚ùå Both migration deploy and schema push failed"
            exit 1
          fi
        fi
        
        echo "‚úÖ Database setup completed successfully!"

    - name: Pull Vercel Environment Information
      run: vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}

    - name: Build Project Artifacts for Vercel
      run: vercel build --prod --token=${{ secrets.VERCEL_TOKEN }}

    - name: Deploy to Vercel
      run: |
        echo "üöÄ Deploying to Vercel..."
        DEPLOYMENT_URL=$(vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }})
        echo "‚úÖ Deployment completed"
        echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
      id: deploy

    - name: Post-Deployment Health Check
      run: |
        echo "üè• Running post-deployment health check..."
        echo "Waiting for deployment to stabilize..."
        sleep 10
        
        # Create health check script
        cat > post-deploy-health-check.js << 'EOF'
        const { PrismaClient } = require('@prisma/client')
        
        const prisma = new PrismaClient()
        
        async function healthCheck() {
          try {
            console.log('üîç Testing database connectivity after deployment...')
            
            // Test connection
            await prisma.$connect()
            console.log('‚úÖ Database connection: OK')
            
            // Test basic operations
            const userCount = await prisma.user.count()
            console.log(`‚úÖ User table: accessible (${userCount} users)`)
            
            const playlistCount = await prisma.playlist.count()
            console.log(`‚úÖ Playlist table: accessible (${playlistCount} playlists)`)
            
            // Test performance
            const start = Date.now()
            await prisma.$queryRaw`SELECT 1 as test`
            const duration = Date.now() - start
            console.log(`‚úÖ Query performance: ${duration}ms`)
            
            if (duration > 3000) {
              console.log('‚ö†Ô∏è Warning: Query took longer than 3 seconds')
            }
            
            console.log('‚úÖ Post-deployment health check passed!')
            
          } catch (error) {
            console.error('‚ùå Post-deployment health check failed:', error.message)
            process.exit(1)
          } finally {
            await prisma.$disconnect()
          }
        }
        
        healthCheck()
        EOF
        
        # Run health check
        if node post-deploy-health-check.js; then
          echo "‚úÖ Post-deployment database health check passed!"
        else
          echo "‚ùå Post-deployment health check failed"
          echo "‚ö†Ô∏è Deployment may still be successful, but database connectivity issues detected"
        fi

    - name: Cleanup Temporary Files
      if: always()
      run: |
        echo "üßπ Cleaning up temporary files..."
        rm -f test-connection.js post-deploy-health-check.js
        echo "‚úÖ Cleanup completed"

    - name: Deployment Summary
      if: always()
      run: |
        echo ""
        echo "üìã Deployment Summary"
        echo "===================="
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ Production deployment successful!"
          if [ -n "${{ steps.deploy.outputs.deployment-url }}" ]; then
            echo "üåê Deployment URL: ${{ steps.deploy.outputs.deployment-url }}"
          else
            echo "üåê Check Vercel dashboard for live URL"
          fi
          echo ""
          echo "üéâ Deployment completed in record time thanks to cached artifacts!"
          echo ""
          echo "üìä Performance optimizations used:"
          echo "  ‚úÖ Reused cached build artifacts from CI"
          echo "  ‚úÖ Skipped redundant dependency installation"
          echo "  ‚úÖ Skipped redundant build process"
          echo "  ‚úÖ Streamlined database operations"
          echo "  ‚úÖ Fast environment verification"
          echo ""
          echo "üîó Next steps:"
          echo "  1. Test authentication with Spotify"
          echo "  2. Verify playlist functionality"
          echo "  3. Monitor application performance"
        else
          echo "‚ùå Production deployment failed"
          echo "Check the logs above for detailed error information"
          echo ""
          echo "üí° Troubleshooting tips:"
          echo "  1. Ensure CI workflow completed successfully"
          echo "  2. Verify all environment variables are set"
          echo "  3. Check database connectivity"
          echo "  4. Validate Vercel token permissions"
          exit 1
        fi
